<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
**Table of Contents**  *generated with [DocToc](https://github.com/thlorenz/doctoc)*

- [UDP](#udp)
- [TCP](#tcp)
  - [三次握手](#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B)
  - [四次挥手](#%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B)
- [为什么不能用两次握手进行连接？](#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E7%94%A8%E4%B8%A4%E6%AC%A1%E6%8F%A1%E6%89%8B%E8%BF%9B%E8%A1%8C%E8%BF%9E%E6%8E%A5)
- [为何连接的时候是三次握手，断开的时候是四次挥手](#%E4%B8%BA%E4%BD%95%E8%BF%9E%E6%8E%A5%E7%9A%84%E6%97%B6%E5%80%99%E6%98%AF%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E6%96%AD%E5%BC%80%E7%9A%84%E6%97%B6%E5%80%99%E6%98%AF%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B)
- [为何客户端TIME_WAIT状态需要等待一段时间才能进入关闭状态](#%E4%B8%BA%E4%BD%95%E5%AE%A2%E6%88%B7%E7%AB%AFtime_wait%E7%8A%B6%E6%80%81%E9%9C%80%E8%A6%81%E7%AD%89%E5%BE%85%E4%B8%80%E6%AE%B5%E6%97%B6%E9%97%B4%E6%89%8D%E8%83%BD%E8%BF%9B%E5%85%A5%E5%85%B3%E9%97%AD%E7%8A%B6%E6%80%81)
- [TCP和UDP的区别](#tcp%E5%92%8Cudp%E7%9A%84%E5%8C%BA%E5%88%AB)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

# UDP
- 面向无连接的
  - 在发送数据之前无需像TCP一样进行3次握手建立连接
  - 不会对数据进行拆分和拼接，仅仅添加上UDP标识就传输给网络层，或者从网络层接收数据去掉IP协议头在传输给应用层
  
- 支持多种传播功能
    
  - UDP 不止支持一对一的传输方式，同样支持一对多，多对多，多对一的方式，也就是说 UDP 提供了单播，多播，广播的功能。

- UDP是面向报文的
  - 对发送的报文接收后添加上UDP协议首部就传向网络层， 不关心报文内容，不拆分也不进行合并，因此传向UDP的报文必须大小合适

- 不可靠性
  - 通信双方无连接
  - 不关心数据内容，也不会备份数据

- UDP头部开销小
  - 两个16位的端口号，源端口号和目标端口号
  - 数据报文长度
  - 数据报文的校验值，用于发现头部信息和数据中的错误

# TCP

- 面向连接的

    面向连接即发送数据之前通信双方必须建立连接，通过三次握手的方式，告诉双方已处在可连接状态，从而建立可靠的连接方式

- 只支持单播的数据传播方式

    TCP连接是两个端点的连接，只能在两个端点之间传动数据，而不是一个点到多个点的传送

- 面向字节流的

    TCP不是对报文的传输， 而是对报文进行拆解，对字节进行编号，针对字节流的传输

- 可靠传输

    TCP对要发送的字节包进行编号，对数据包挨个传输，服务端接收到数据包后返回一个ACK确认信息，用来确认该包已正确接收。如果未收到确认则认为该报丢失，会重新发送该包，保证了数据传输的准确性

- 提供拥塞控制

    当网络阻塞时， TCP会减少向网络发送数据包的频率和数量，从而缓解阻塞

- TCP提供全双工通信

    TCP允许通信双方的应用程序在任何时候都能发送数据，因为TCP连接的两端都设有缓存，用来临时存放双向通信的数据

## 三次握手
1. 客户端向服务器端发送连接请求报文，包含连接请求标识SYN(SYN=1表示连接请求生效，等于0表示不生效), 以及初始连接序列号seq，进入已发送状态（SYN-SENT）
   
        SYN=1, seq=X

2. 服务器端接收到请求报文后，确认连接，返回一个确认报文,包括应答标识ACK=(原seq+1,表明自己是对那个请求做的应答)，数据包，发送后服务端进入已接收状态（SYN-RECEIVED ）

        ACK=1, SYN=1, ack=X+1, seq=Y

3. 客户端在接收到应答后，返回给服务器响应，并进入链接已建立状态(ESTABLISHED)

        ACK=1, ack=Y+1

4. 服务器接收到客户端的ACK响应报文后，进入连接已建立状态（ESTABLISHED）
5. 之后正式进入通信状态

## 四次挥手
1. 客户端发送请求到服务端，请求断开连接，同时自己进入等待终止状态(FIN-WAIT-1)， 不在发送数据包

        FIN=1, seq=u
2. 服务器端接收到断开来连接的请求后，响应客户端已接收到断开响应的意图，向客户端发送响应.进入关闭等待状态（CLOSE-WAIT） 

        ACK=1, ack=u+1, seq=p

    tcp传输数据以字节为单位，ack＋1是代表之前的数据已经接收了，期望下次接收从下一个字节开始的数据包

    客户端收到ACK响应后，进入到终止等待状态（FIN-WAIT-2），等待服务器端发送断开连接的报文
3. 服务器端发送断开连接的报文，进入最后的确认状态（LAST-ACK）

        FIN=1, ACK=1, ack=u+1, seq=w

4. 客户端收到断开连接的报文后，向服务器发出响应报文，同时进入TIME_WAIT状态，该状态会持续两个报文在网络中所存在的最大时间，超过这个时间后进入关闭状态

        ACK=1,ack=w+1

    服务器端收到响应后， 断开TCP连接

# 为什么不能用两次握手进行连接？
TCP协议的目的是建立一种可靠的数据传输，保证通信双方处于建立好连接的状态。

# 为何连接的时候是三次握手，断开的时候是四次挥手

建立tcp连接过程中，服务端收到来自客户端的SYN请求建立连接报文， 可以直接响应报文告诉客户端已收到请求可以连接。而在断开tcp连接的时候，服务端收到断开请求，需要先发ACK响应，告诉客户端已收到了断开请求，需要看下是否还有数据需要从服务器端发送到客户端，发送完数据后，在给客户端发送断开连接的FIN响应。因此确认消息的响应个断开连接的响应不能一块发送

# 为何客户端TIME_WAIT状态需要等待一段时间才能进入关闭状态
防止发送到服务端的最后一个ACK报文丢失， 如果服务端一直没有接收到最后的ACK报文，不会进入关闭状态， 而是向客户端重发FIN报文， 直到接收到来自客户端的响应才会真正进入到close状态。

如果客户端在TIME_WAIT状态接受到了FIN报文，则会重新进入2MSL等待时间

MSL指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间


# TCP和UDP的区别
- TCP是面向连接的，UDP是无连接的。发送数据之前TCP需要通信双方通过三次握手建立点到点的可靠连接，UDP不需要
- TCP是面向字节流的传输，UDP是面向报文的传输。TCP对来自应用层的报文进行拆解为字节包，为包添加上自己的协议头部并编号在传输。UDP不会对来自上层的数据包进行拆解
- TCP是可靠的数据传输，UDP不保证可靠性。TCP通过流量控制，序列号控制保证数据有序安全的传输， 如果发生丢包，则会重传。UDP至尽可能的传输数据并报保证数据的完整性和安全性
- TCP只支持连接双方点到点的传输，UDP支持多种传播方式，可以一对一，一对多，多对多的传输
- TCP首部开销大，最小20字节，最大60字节消耗更多的系统资源。UDP首部开销小，仅仅8字节