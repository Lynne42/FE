<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
**Table of Contents**  *generated with [DocToc](https://github.com/thlorenz/doctoc)*

- [JS运行环境](#js%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83)
- [执行上下文](#%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87)
- [调用栈](#%E8%B0%83%E7%94%A8%E6%A0%88)
  - [创建执行上下文](#%E5%88%9B%E5%BB%BA%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87)
    - [创建变量对象](#%E5%88%9B%E5%BB%BA%E5%8F%98%E9%87%8F%E5%AF%B9%E8%B1%A1)
    - [建立作用于链](#%E5%BB%BA%E7%AB%8B%E4%BD%9C%E7%94%A8%E4%BA%8E%E9%93%BE)
    - [作用域](#%E4%BD%9C%E7%94%A8%E5%9F%9F)
- [参考](#%E5%8F%82%E8%80%83)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

# JS运行环境

- **全局环境**

  js代码加载完成后， 进行代码预编译即进入全局环境

- **函数环境**

  函数调用执行时，进入该函数环境，不同的函数函数环境不同

- **eval环境**

每进入一个运行环境，便会创建一个```执行上下文(Execution Context)```

在一段JS代码中一般会创建多个执行上下文

JS引擎会已栈的形式对这些执行上下文进行处理形成```函数调用栈(call stack)```.



# 执行上下文

每进入一个执行环境便会创建一个执行上下文， 根据执行环境的不同， 执行上下文包含三种类型：

- **全局执行上下文**
  
  只有一个，浏览器中的全局对象就是window对象， this指向这个全局对象

  首次运行JS代码会创建一个全局执行上下文，比推送到当前执行栈中。

- **函数执行上下文**
  
  存在多个，只有函数被调用的时候才会创建， 每次调用函数都会创建一个新的执行上下文

  即使调用函数自身，也会创建新的执行上下文

  将改执行上下文推送到当前执行栈中。

- **eval执行上下文**

  运行在 eval 函数中的代码，很少用而且不建议使用


# 调用栈

**用来存储代码执行期间创建的所有执行上下文， 具有栈的特性， 先进后出**

- 首次运行JS代码会创建一个全局执行上下文，并将其push到当前调用栈中
- 每次函数被调用， 便会创建一个函数执行上下文，并将其push到当前调用栈中
- 根据栈的先进后出原则，栈顶函数执行完成后，便会将该函数调用栈pop出调用栈，上下文控制执行权被移交到下一个执行上下文

```
var a = 'Hello World!';

function first() {  
  console.log('Inside first function');  
  second();  
  console.log('Again inside first function');  
}

function second() {  
  console.log('Inside second function');  
}

first();  
console.log('Inside Global Execution Context');

```
![调用栈](./img/stack.webp)

- JS加载改代码块， 进行语法分析阶段，没有问题， 则进入预编译阶段
- 创建全局函数执行上下文，并推入stack调用栈中
- 编译向下遇到first函数调用，进入first函数运行环境，创建fisrt函数执行上下文， 并将其推送到stack调用栈中
- 在first函数运行环境中， 遇到second()函数调用，进入second函数运行环境， 并创建second函数执行上下文，推入到调用栈中
- second函数后没有其他执行环境，则开始出栈

---

## 创建执行上下文
执行上下文的创建分为两个阶段：
- ```创建阶段(函数被调用时，进入函数环境，为其创建一个执行上下文，此时进入创建阶段)```
  - [创建变量对象](#创建变量对象)
    - 函数环境下初始化argument对象，并赋值
    - 函数声明，并赋值
    - 变量声明， 函数表达式声明（未赋值）
  - [建立作用域链](#建立作用于链)
  - 确定this指向

- ```执行阶段(执行函数中代码时，此时执行上下文进入执行阶段)```
  - 变量对象赋值
    - 变量赋值
    - 函数表达式赋值
  - 调用函数
  - 顺序执行

```创建阶段对函数声明赋值， 对对象和函数表达式只做声明不做赋值， 等到执行才会进行赋值```，这也是导致变量提升的原因

**```变量对象创建优先级:```**
1. 函数声明， 如果出现同名函数， 则后面的的函数替换前面的函数
2. 变量声明，函数表达式，按照代码顺序创建

***变量对象和活动对象的区别：***

当进入到一个执行上下文后，这个变量对象才会被激活，所以叫活动对象(AO)，这时候活动对象上的各种属性才能被访问

---
### 创建变量对象
- 创建```argument对象```，检查当前上下文参数，创建该对象的属性和属性值，仅在函数环境(非箭头函数)中进行，全局环境没有该过程
- 顺序查找当前上下文中的```函数声明```，提升函数声明
  - 同名函数声明， 后面的函数覆盖前面的函数
- 顺序查找当前上下文中的```变量声明```，提升变量声明
  - 同名变量， 后面的覆盖前面的
  - 同名函数表达式， 后面的覆盖前面的
  - 函数表达式与函数声明同名， 则函数表达式函数覆盖函数声明函数

### 建立作用于链
**作用域链由当前执行环境的变量对象和上层环境(上层执行上下文环境)的一些列活动对象组成**

作用域链保证了变量和函数的有序访问，查找方式是沿着作用域链从左至右查找变量或函数，找到则会停止查找，找不到则一直查找到全局作用域，再找不到则会抛出引用错误


### 作用域
作用域可以理解为一个独立的可访问空间，可以隔离变量， 让变量不会泄露出去

- 全局作用域
  - 代码块最外层函数 和在最外层函数外面定义的变量拥有全局作用域
  - 所有末定义直接赋值的变量自动声明为拥有全局作用域
  - 所有window对象的属性拥有全局作用域
- 函数作用域
  - 声明在函数内容的变量
- 块作用域



# 参考
- [理解JS中的执行上下文和执行栈](https://github.com/yygmind/blog/issues/12)
- [js引擎的执行过程（一）](https://heyingye.github.io/2018/03/19/js%E5%BC%95%E6%93%8E%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89)